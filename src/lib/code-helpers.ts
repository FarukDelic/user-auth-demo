/**
 * Code generation utilities and helpers
 * Generated by claude-code MCP
 */

export interface CodeTemplate {
  name: string
  description: string
  template: string
  language: 'typescript' | 'javascript' | 'tsx' | 'jsx'
}

export const codeTemplates: CodeTemplate[] = [
  {
    name: 'React Functional Component',
    description: 'A basic functional React component with TypeScript',
    language: 'tsx',
    template: `import React from 'react'

interface {{ComponentName}}Props {
  // Add your props here
}

export const {{ComponentName}}: React.FC<{{ComponentName}}Props> = (props) => {
  return (
    <div>
      <h1>{{ComponentName}}</h1>
      {/* Your component content here */}
    </div>
  )
}

export default {{ComponentName}}`
  },
  {
    name: 'Custom Hook',
    description: 'A custom React hook template',
    language: 'ts',
    template: `import { useState, useEffect } from 'react'

export const use{{HookName}} = (initialValue?: any) => {
  const [value, setValue] = useState(initialValue)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    // Your hook logic here
  }, [])

  return {
    value,
    setValue,
    loading,
    error
  }
}`
  },
  {
    name: 'API Route Handler',
    description: 'Next.js API route handler',
    language: 'ts',
    template: `import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Your GET logic here
    return NextResponse.json({ message: 'Success' })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    // Your POST logic here
    return NextResponse.json({ message: 'Created successfully' })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}`
  },
  {
    name: 'TypeScript Interface',
    description: 'A comprehensive TypeScript interface definition',
    language: 'ts',
    template: `export interface {{InterfaceName}} {
  id: string
  name: string
  email: string
  createdAt: Date
  updatedAt: Date
  // Add more properties as needed
}

export interface {{InterfaceName}}CreateInput {
  name: string
  email: string
}

export interface {{InterfaceName}}UpdateInput {
  name?: string
  email?: string
}`
  }
]

/**
 * Generate code from a template with variable substitution
 */
export const generateCodeFromTemplate = (
  template: CodeTemplate,
  variables: Record<string, string>
): string => {
  let code = template.template
  
  // Replace variables in the template
  Object.entries(variables).forEach(([key, value]) => {
    const regex = new RegExp(`{{${key}}}`, 'g')
    code = code.replace(regex, value)
  })
  
  return code
}

/**
 * Validate variable names for code generation
 */
export const validateVariableName = (name: string): boolean => {
  // Check if it's a valid JavaScript/TypeScript identifier
  const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/
  return validIdentifier.test(name)
}

/**
 * Convert string to PascalCase for component names
 */
export const toPascalCase = (str: string): string => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
      return index === 0 ? word.toUpperCase() : word.toUpperCase()
    })
    .replace(/\s+/g, '')
}

/**
 * Convert string to camelCase for variable names
 */
export const toCamelCase = (str: string): string => {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
      return index === 0 ? word.toLowerCase() : word.toUpperCase()
    })
    .replace(/\s+/g, '')
}

/**
 * Generate a complete file structure for a feature
 */
export const generateFeatureStructure = (featureName: string) => {
  const pascalName = toPascalCase(featureName)
  const camelName = toCamelCase(featureName)
  
  return {
    component: generateCodeFromTemplate(codeTemplates[0], { ComponentName: pascalName }),
    hook: generateCodeFromTemplate(codeTemplates[1], { HookName: pascalName }),
    types: generateCodeFromTemplate(codeTemplates[3], { InterfaceName: pascalName }),
    api: generateCodeFromTemplate(codeTemplates[2], {}),
    files: [
      `components/${pascalName}.tsx`,
      `hooks/use${pascalName}.ts`,
      `types/${camelName}.ts`,
      `api/${camelName}/route.ts`
    ]
  }
}

/**
 * Code formatting utilities
 */
export const formatCode = (code: string, language: string): string => {
  // Basic formatting - in a real implementation, you'd use prettier or similar
  return code
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0)
    .join('\n')
}

export default {
  codeTemplates,
  generateCodeFromTemplate,
  validateVariableName,
  toPascalCase,
  toCamelCase,
  generateFeatureStructure,
  formatCode
}